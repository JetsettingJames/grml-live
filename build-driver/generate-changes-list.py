#!/usr/bin/env python3
import os
import subprocess
import sys
import re
from pathlib import Path


class Listener:
    def __init__(self):
        self.failed = False

    def error(self, message: str):
        raise NotImplementedError

    def info(self, message: str):
        raise NotImplementedError

    def warn(self, message: str):
        raise NotImplementedError


class CliListener(Listener):
    def error(self, message: str):
        self.failed = True
        sys.stderr.write(f"E: {message}\n")

    def info(self, message: str):
        sys.stdout.write(f"I: {message}\n")

    def warn(self, message: str):
        sys.stdout.write(f"W: {message}\n")


def run_x(args, check: bool = True, **kwargs):
    # str-ify Paths, not necessary, but for readability in logs.
    args = [arg if isinstance(arg, str) else str(arg) for arg in args]
    args_str = '" "'.join(args)
    print(f'D: Running "{args_str}"', flush=True)
    return subprocess.run(args, check=check, **kwargs)


def parse_package_list(s: str) -> dict:
    package_dict = {}
    for line in s.split("\n"):
        match = re.match(r"^ii\s+(\S+)\s+(\S+)\s", line)
        if match:
            package_dict[match[1]] = match[2]
    return package_dict


def sort_people(people: list[str]) -> list[str]:
    """Sort list of names, ignoring case"""
    return sorted(people, key=lambda v: v.upper())


def unique_case_insensitive(strings: list[str]):
    seen = set()
    unique_strings = []
    for string in strings:
        upper = string.upper()
        if upper in seen:
            continue
        seen.add(upper)
        unique_strings.append(string)
    return unique_strings


def build_changes(
    output_filename: Path,
    dpkg_list_new: Path,
    dpkg_list_old: Path,
    package_prefix: str,
    git_url_base: str,
    git_repo_workspace: Path,
    job_name: str,
    build_id: str,
    listener: Listener,
):
    git_repo_workspace.mkdir(parents=True, exist_ok=True)
    all_people = []

    changelog = f"""------------------------------------------------------------------------
Generated by CI for job {job_name} {build_id}
------------------------------------------------------------------------
"""

    if not dpkg_list_new.exists():
        listener.error(f"Could not read package list {dpkg_list_new}")
        return

    packages = parse_package_list(dpkg_list_new.read_text())
    packages_old = {}
    try:
        packages_old = parse_package_list(dpkg_list_old.read_text())
    except Exception as e:
        listener.info(f"While parsing old package list: {e}")

    debian_changes = {"removed": [], "added": [], "changed": []}

    for package in set(packages_old) - set(packages):
        if re.match(f"^{package_prefix}", package):
            changelog += f"""Package {package}: Removed.
------------------------------------------------------------------------
"""
        else:
            debian_changes["removed"].append(package)

    for package, version in packages.items():
        old_version = packages_old.get(package)
        if re.match(f"^{package_prefix}", package):
            try:
                listener.info(f"Generating changes list for package {package}...")
                if old_version:
                    listener.info(f"Version {old_version} -> {version}")
                    if old_version == version:
                        continue

                git_url = f"{git_url_base}/{package}"
                gitpath = fetch_grml_package_repo(git_repo_workspace, package, git_url)

                if old_version:
                    range = f"v{old_version}..v{version}"
                else:
                    range = f"v{version}"

                commits, people = get_grml_package_changes(gitpath, range)
                all_people.extend(people)
                commit_list = "\n    ".join(commits)
                people_list = "\n    ".join(sort_people(people))
                changelog += f"""Package {package}: {range} {'(new)' if not old_version else ''}
    {commit_list}
People:
    {people_list}
------------------------------------------------------------------------
"""
            except Exception as e:
                listener.warn(f"Generating change report for package {package} failed: {e}")
                changelog += f"""Package {package}: [failed]
------------------------------------------------------------------------
"""

        else:
            if old_version:
                if old_version == version:
                    continue
                debian_changes["changed"].append(f"{package} {old_version} -> {version}")
            else:
                debian_changes["added"].append(package)


    all_people = unique_case_insensitive(all_people)
    all_people_list = "\n    ".join(sort_people(all_people))
    changelog += f"""All involved people:
    {all_people_list}
------------------------------------------------------------------------
"""

    changelog += """Changes to Debian package list:
  Added:
    {}
  Changed:
    {}
  Removed:
    {}
------------------------------------------------------------------------
""".format(
        "\n    ".join(debian_changes["added"]).strip(),
        "\n    ".join(debian_changes["changed"]).strip(),
        "\n    ".join(debian_changes["removed"]).strip(),
    )

    output_filename.write_text(changelog)


def main() -> int:
    if len(sys.argv) != 9:
        print(
            f"Usage: {sys.argv[0]} output_filename dpkg_list_new dpkg_list_old package_prefix git_url_base git_repo_workspace job_name build_id"
        )
        return 2

    listener = CliListener()
    try:
        build_changes(
            Path(sys.argv[1]),
            Path(sys.argv[2]),
            Path(sys.argv[3]),
            sys.argv[4],
            sys.argv[5],
            Path(sys.argv[6]),
            sys.argv[7],
            sys.argv[8],
            listener,
        )
    except Exception as except_inst:
        listener.error(f"Uncaught exception: {except_inst}")

    if listener.failed:
        return 1
    return 0


def fetch_grml_package_repo(git_repo_workspace: Path, package: str, git_url: str) -> Path:
    """Clone and update git repository."""
    gitpath = git_repo_workspace / f"{package}.git"
    if not gitpath.exists():
        env = dict(os.environ) | {"GIT_TERMINAL_PROMPT": "0"}
        run_x(
            ["git", "clone", "--bare", "--single-branch", git_url, gitpath],
            cwd=git_repo_workspace,
            env=env,
        )
    if not gitpath.exists():
        raise Exception("Repository not found")

    # update repo
    run_x(["git", "remote", "set-url", "origin", git_url], cwd=gitpath)
    run_x(["git", "remote", "update", "--prune"], cwd=gitpath).check_returncode()
    return gitpath


def get_grml_package_changes(gitpath: Path, range: str) -> tuple[list[str], list[str]]:
    trailers = ["Thanks", "Reported-By"]

    git_format = "--format=tformat:Commit: %H %s%nAuthor: %aN%nCommitter: %cN%n"
    for trailer in trailers:
        git_format += f"%(trailers:key={trailer})%n"

    git_log = run_x(["git", "log", git_format, range], cwd=gitpath, capture_output=True)

    changes = []
    people = []
    for line in git_log.stdout.decode().splitlines():
        line = line.strip()
        if not line:
            continue
        key, value = line.split(': ', 1)
        if key == 'Commit':
            changes.append(value)
        else:
            people.append(value)

    return changes, unique_case_insensitive(people)


if __name__ == "__main__":
    sys.exit(main())
